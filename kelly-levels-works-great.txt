//
// Copyright (C) 2021, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.Indicators;
using NinjaTrader.NinjaScript.DrawingTools;
//using NinjaTrader.NinjaScript.Indicators.TDU;

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Gui.Tools;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;

#endregion

/*
ES : TP 4, extra 1
YM : TP 10, extra 2
NQ : TP 7, extra 2
RTY: TP 4, extra 8
*/
namespace NinjaTrader.NinjaScript.Strategies
{
    public class KellyGoldSilverStrategy : Strategy
    {
		private Series<double> barHigh;
		private Series<double> barLow;
		private Series<double> barClose;
		 NinjaTrader.NinjaScript.Indicators.KellyAnn.Nearest4Levels Nearest4Levels1;

		private string  atmStrategyId			= string.Empty;
		private string  orderId					= string.Empty;
		private bool	isAtmStrategyCreated	= false;
		
        private int _lastBar = 0;
		private double _lastLevel;
        private double _lastLevel1;
		private double _lastLevel2;
		private double _lastLevel3;
		private double _lastLevel4;
		private double _lastLevel5;
		private double _lastLevel6;
		private double _lastLevel7;
		private double _lastLevel8;
		
		// New variables for session tracking and timing
		private bool hasDroppedBelowLevelCToday = false;
		private int levelCDropBar = -1;
		private bool canBuyAtLevelB = false;
		private bool hasRisenAboveLevelAToday = false;
		private int levelARiseBar = -1;
		private bool canSellAtLevelD = false;
		private int currentSessionDate = 0;
		
		// New variables for time-based trading conditions
		private DateTime levelCDropTime = DateTime.MinValue;
		private bool canBuyAtLevelBFromC = false;
		private DateTime levelARiseTime = DateTime.MinValue;
		private bool canSellAtLevelBFromA = false;
		private DateTime levelADropTime = DateTime.MinValue;
		private bool canBuyAtLevelDFromA = false;
		private DateTime levelCRiseTime = DateTime.MinValue;
		private bool canSellAtLevelDFromC = false;
		private DateTime lastTradeTime = DateTime.MinValue;
		
		// Daily win/loss tracking variables
		private int dailyWins = 0;
		private int dailyLosses = 0;
		private int maxWinsPerDay = 5;
		private int maxLossesPerDay = 3;
		private int currentTradingDate = 0;
		
		// Error handling and order management
		private bool orderErrorOccurred = false;
		private DateTime lastErrorTime = DateTime.MinValue;
		private int consecutiveErrors = 0;
		private int maxConsecutiveErrors = 3;
		
		private int		breakEvenTicks		= 4;//default 5, 6		// Default setting for ticks needed to acheive before stop moves to breakeven		
		private int		plusBreakEven		= 0; //default 3, 2		// Default setting for amount of ticks past breakeven to actually breakeven
		private int		profitTargetTicks	= 400;//default 200		// Default setting for how many Ticks away from AvgPrice is profit target
        private int		stopLossTicks		= 22;//default 8, 6		// Default setting for stoploss. Ticks away from AvgPrice
		private int		trailingStopTicks	= 4;				// Trailing stop distance in ticks
		private int		trailProfitTrigger	= 5;//default 9	, 8	// 8 Default Setting for trail trigger ie the number of ticks movede after break even befor activating TrailStep
		private int		trailStepTicks		= 1;//default 3, 2		// 2 Default setting for number of ticks advanced in the trails - take into consideration the barsize as is calculated/advanced next bar
		private int 	BarTraded 			= 0; //default 0		// Default setting for Bar number that trade occurs	
		
		private bool	showLines			= true;		// Turn on/off the profit targett, stoploss and trailing stop plots  // new for NT8
		
		private double	initialBreakEven	= 0; 		// Default setting for where you set the breakeven
		private double 	previousPrice		= 0;		// previous price used to calculate trailing stop
		private double 	newPrice			= 0;		// Default setting for new price used to calculate trailing stop
		private double	stopPlot			= 0;		// Value used to plot the stop level

        protected override void OnStateChange()
        {
            if (State == State.SetDefaults)
            {
                Description = "KellyGoldSilverStrategy";
                Name = "KellyGoldSilverStrategy";
				
				AddPlot(new Stroke(Brushes.Transparent, 2), PlotStyle.Line, "InvisiblePlot");
				
                TakeProfit = 7;
                IsInstantiatedOnEachOptimizationIteration = false;
//                Calculate = Calculate.OnEachTick;
				Calculate = Calculate.OnPriceChange;
//				Calculate = Calculate.OnBarClose;
                ExtraSLTicks = 2;
                ExtraRetracementTicks = 2;
//                MinTouches = 0;
                IncludeCommission = true;
                RealtimeErrorHandling = RealtimeErrorHandling.IgnoreAllErrors;
                IsExitOnSessionCloseStrategy = false;
				
//				IsSuspendedWhileInactive = false;
//                PaintPriceMarkers = false;
                DisplayInDataBox = false;
                DrawOnPricePanel = true;
                BarsRequiredToPlot = 4;
                IsAutoScale = false;
                IsOverlay = true;
				
//                AddPlot(new Stroke(Brushes.Transparent, 2), PlotStyle.Line, "InvisiblePlot");
				
                LevelA = 0;
                LevelB = 26;
                LevelC = 50;
                LevelD = 77;
				
				LevelALine = new Stroke(Brushes.Blue);
				LevelBLine = new Stroke(Brushes.Green);
				LevelCLine = new Stroke(Brushes.Red);
				LevelDLine = new Stroke(Brushes.Purple);
				
				

            }
            else if (State == State.Configure)
            {
//                AddDataSeries(BarsPeriodType.Tick, 1);
				
				barHigh = new Series<double>(this);
				barLow = new Series<double>(this);
				barClose = new Series<double>(this);
				
				SetStopLoss(CalculationMode.Ticks, stopLossTicks);
				SetProfitTarget(CalculationMode.Ticks, profitTargetTicks);	
            }
            else if (State == State.DataLoaded)
            {
//				TrendMagic1				= TrendMagic(Close, 20, 14, 1, false);
//				TrendMagic1.Plots[0].Brush = Brushes.Orange;
//				TrendMagic1.Plots[1].Brush = Brushes.Transparent;
//				TrendMagic1.Plots[2].Brush = Brushes.Transparent;
//				AddChartIndicator(TrendMagic1);
				
//                _sr = TDUSupportResistance(Close, TDUSRZoneType.Line,10,16,16,50,15,15,TDUZoneBreakType.CandleClosesOutsideZone,false,BarsPeriodType.Minute,5,1000,"jonesy3@gmail.com",6381183434951);
//                _sr.ShowBrokenLines = false;
//                _sr.ShowBroken = false;
//				_sr.ShowPreviousTouches= false;
//				_sr.ShowPrice= false;
//				_sr.ShowPreviousTouchesCount=false;

//                AddChartIndicator(_sr);
				
//				Nearest4Levels1				= Nearest4Levels(Close, 0, 26, 50, 77, NinjaTrader.Gui.Stroke, NinjaTrader.Gui.Stroke, NinjaTrader.Gui.Stroke, NinjaTrader.Gui.Stroke);
//				Nearest4Levels1.Plots[0].Brush = Brushes.Transparent;
//				AddChartIndicator(Nearest4Levels1);
            }
        }

        protected override void OnBarUpdate()
        {
            if (BarsInProgress != 0) return;
            if (CurrentBar < BarsRequiredToTrade)
                return;
            if (_lastBar == CurrentBar) return;
			// Make sure this strategy does not execute against historical data
			if(State == State.Historical)
				return;
			
			// Reset session tracking at start of new session
			int todayDate = Time[0].Date.Day + Time[0].Date.Month * 100 + Time[0].Date.Year * 10000;
			if (currentSessionDate != todayDate)
			{
				currentSessionDate = todayDate;
				// Reset all time-based conditions for new session
				levelCDropTime = DateTime.MinValue;
				canBuyAtLevelBFromC = false;
				levelARiseTime = DateTime.MinValue;
				canSellAtLevelBFromA = false;
				levelADropTime = DateTime.MinValue;
				canBuyAtLevelDFromA = false;
				levelCRiseTime = DateTime.MinValue;
				canSellAtLevelDFromC = false;
				lastTradeTime = DateTime.MinValue;
				
				// Reset daily win/loss counters for new trading day
				dailyWins = 0;
				dailyLosses = 0;
				orderErrorOccurred = false;
				consecutiveErrors = 0;
				Print("New trading day started - Win/Loss counters reset. Max wins: " + maxWinsPerDay + ", Max losses: " + maxLossesPerDay);
			}
			
			barHigh[0] = High[0];
			barLow[0] = Low[0];
			barClose[0] = Low[0];
			
			#region Calculate
            double price = Close[0];
            double priceInt = Math.Floor(Math.Floor(price)/100);
			
			double LevelAValue = (priceInt + (LevelA / 100.0)) * 100;
            double LevelBValue = (priceInt + (LevelB / 100.0)) * 100;
            double LevelCValue = (priceInt + (LevelC / 100.0)) * 100;
            double LevelDValue = (priceInt + (LevelD / 100.0)) * 100;
			

            if (price < LevelAValue)
            {
                LevelAValue -= 1.0;
                LevelBValue -= 1.0;
                LevelCValue -= 1.0;
                LevelDValue -= 1.0;
				
            }
			#endregion
			
			#region Time-Based Trading Logic
			
			// Condition 1: Buy at LevelB when price crosses below LevelC and reaches LevelB within 5 minutes
			if (CrossBelow(Low, LevelCValue, 1))
			{
				levelCDropTime = Time[0];
				canBuyAtLevelBFromC = true;
				Print("Price dropped below LevelC (" + LevelCValue + ") at " + levelCDropTime.ToString("HH:mm:ss") + " - Can now buy at LevelB (" + LevelBValue + ") within 5 minutes");
			}
			
			// Check if 5 minutes have passed since dropping below LevelC
			if (canBuyAtLevelBFromC && levelCDropTime != DateTime.MinValue)
			{
				TimeSpan timeSinceDrop = Time[0] - levelCDropTime;
				if (timeSinceDrop.TotalMinutes > 5)
				{
					canBuyAtLevelBFromC = false;
					Print("5 minute window expired - No longer eligible to buy at LevelB (" + LevelBValue + ")");
				}
			}
			
			// Condition 2: Sell at LevelB when price crosses above LevelA and reaches LevelB within 5 minutes
			if (CrossAbove(High, LevelAValue, 1))
			{
				levelARiseTime = Time[0];
				canSellAtLevelBFromA = true;
				Print("Price rose above LevelA (" + LevelAValue + ") at " + levelARiseTime.ToString("HH:mm:ss") + " - Can now sell at LevelB (" + LevelBValue + ") within 5 minutes");
			}
			
			// Check if 5 minutes have passed since rising above LevelA
			if (canSellAtLevelBFromA && levelARiseTime != DateTime.MinValue)
			{
				TimeSpan timeSinceRise = Time[0] - levelARiseTime;
				if (timeSinceRise.TotalMinutes > 5)
				{
					canSellAtLevelBFromA = false;
					Print("5 minute window expired - No longer eligible to sell at LevelB (" + LevelBValue + ")");
				}
			}
			
			// Condition 3: Buy at LevelD when price crosses below LevelA and reaches LevelD within 5 minutes
			if (CrossBelow(Low, LevelAValue, 1))
			{
				levelADropTime = Time[0];
				canBuyAtLevelDFromA = true;
				Print("Price dropped below LevelA (" + LevelAValue + ") at " + levelADropTime.ToString("HH:mm:ss") + " - Can now buy at LevelD (" + LevelDValue + ") within 5 minutes");
			}
			
			// Check if 5 minutes have passed since dropping below LevelA
			if (canBuyAtLevelDFromA && levelADropTime != DateTime.MinValue)
			{
				TimeSpan timeSinceDrop = Time[0] - levelADropTime;
				if (timeSinceDrop.TotalMinutes > 5)
				{
					canBuyAtLevelDFromA = false;
					Print("5 minute window expired - No longer eligible to buy at LevelD (" + LevelDValue + ")");
				}
			}
			
			// Condition 4: Sell at LevelD when price crosses above LevelC and reaches LevelD within 5 minutes
			if (CrossAbove(High, LevelCValue, 1))
			{
				levelCRiseTime = Time[0];
				canSellAtLevelDFromC = true;
				Print("Price rose above LevelC (" + LevelCValue + ") at " + levelCRiseTime.ToString("HH:mm:ss") + " - Can now sell at LevelD (" + LevelDValue + ") within 5 minutes");
			}
			
			// Check if 5 minutes have passed since rising above LevelC
			if (canSellAtLevelDFromC && levelCRiseTime != DateTime.MinValue)
			{
				TimeSpan timeSinceRise = Time[0] - levelCRiseTime;
				if (timeSinceRise.TotalMinutes > 5)
				{
					canSellAtLevelDFromC = false;
					Print("5 minute window expired - No longer eligible to sell at LevelD (" + LevelDValue + ")");
				}
			}
			#endregion
			
			#region Plot
            Draw.HorizontalLine(this, "LevelA"+LevelAValue, LevelAValue, LevelALine.Brush, LevelALine.DashStyleHelper
				, (int) LevelALine.Width);
            Draw.HorizontalLine(this, "LevelB"+LevelBValue, LevelBValue, LevelBLine.Brush, LevelBLine.DashStyleHelper
				, (int) LevelBLine.Width);
            Draw.HorizontalLine(this, "LevelC"+LevelCValue, LevelCValue, LevelCLine.Brush, LevelCLine.DashStyleHelper
				, (int) LevelCLine.Width);
            Draw.HorizontalLine(this, "LevelD"+LevelDValue, LevelDValue, LevelDLine.Brush, LevelDLine.DashStyleHelper
				, (int) LevelDLine.Width);
			#endregion
			
			// Enhanced trailing stop system using existing code structure
			switch (Position.MarketPosition)
            {
				// Resets the stop loss to the original value when all positions are closed
                case MarketPosition.Flat:
                    SetStopLoss(CalculationMode.Ticks, stopLossTicks);
					previousPrice = 0;
					stopPlot = 0;
                    break;
					   
                case MarketPosition.Long:
					try
					{
						if (previousPrice == 0)
						{
							stopPlot = Position.AveragePrice - stopLossTicks * TickSize;  // initial stop plot level
						}
						
						// Once the price is greater than entry price+ breakEvenTicks ticks, set stop loss to plusBreakeven ticks
						if (Close[0] > Position.AveragePrice + breakEvenTicks * TickSize  && previousPrice == 0)
						{
							initialBreakEven = Position.AveragePrice + plusBreakEven * TickSize;
							SetStopLoss(CalculationMode.Price, initialBreakEven);
							previousPrice = Position.AveragePrice;
							stopPlot = initialBreakEven;
							Print("Long position moved to breakeven at: " + initialBreakEven);
						}
						// Once at breakeven wait till trailProfitTrigger is reached before advancing stoploss by trailStepTicks size step
						else if (previousPrice != 0 // StopLoss is at breakeven
								&& Close[0] > previousPrice + trailProfitTrigger * TickSize )
						{
							newPrice = previousPrice + trailStepTicks * TickSize; 	// Calculate trail stop adjustment
							SetStopLoss(CalculationMode.Price, newPrice);			// Readjust stoploss level		
							previousPrice = newPrice;				 				// save for price adjust on next candle
							stopPlot = newPrice; 					 				// save to adjust plot line
							Print("Long trailing stop advanced to: " + newPrice);
						}
						
						// Plot the profit/stop lines
						if (showLines)
						{
							ProfitTarget[0] = Position.AveragePrice + profitTargetTicks * TickSize;
							StopLoss[0] 	= stopPlot;
						}
					}
					catch (Exception ex)
					{
						Print("Error in Long position management: " + ex.Message);
						HandleOrderError();
					}
                    break;
					
                case MarketPosition.Short:
					try
					{
						if (previousPrice == 0) 
						{
							stopPlot = Position.AveragePrice + stopLossTicks * TickSize;  // initial stop plot level
						}
						
						// Once the price is Less than entry price - breakEvenTicks ticks, set stop loss to breakeven
						if (Close[0] < Position.AveragePrice - breakEvenTicks * TickSize && previousPrice == 0)
						{
							initialBreakEven = Position.AveragePrice - plusBreakEven * TickSize;
							SetStopLoss(CalculationMode.Price, initialBreakEven);
							previousPrice = Position.AveragePrice;
							stopPlot = initialBreakEven;
							Print("Short position moved to breakeven at: " + initialBreakEven);
						}
						// Once at breakeven wait till trailProfitTrigger is reached before advancing stoploss by trailStepTicks size step
						else if (previousPrice != 0 // StopLoss is at breakeven
								&& Close[0] < previousPrice - trailProfitTrigger * TickSize )
						{
							newPrice = previousPrice - trailStepTicks * TickSize;
							SetStopLoss(CalculationMode.Price, newPrice);
							previousPrice = newPrice;
							stopPlot = newPrice;
							Print("Short trailing stop advanced to: " + newPrice);
						}
						
						if (showLines)
						{
							ProfitTarget[0] = Position.AveragePrice - profitTargetTicks * TickSize;
							StopLoss[0] 	= stopPlot;
						}
					}
					catch (Exception ex)
					{
						Print("Error in Short position management: " + ex.Message);
						HandleOrderError();
					}
                    break;
                default:
                    break;
			}
			
            if (Position.MarketPosition == MarketPosition.Flat)
            {
				// Check daily win/loss limits
				if (dailyWins >= maxWinsPerDay)
				{
					Print("Daily win limit reached (" + maxWinsPerDay + "). No more trades today.");
					return;
				}
				
				if (dailyLosses >= maxLossesPerDay)
				{
					Print("Daily loss limit reached (" + maxLossesPerDay + "). No more trades today.");
					return;
				}
				
				// Check for recent errors
				if (orderErrorOccurred && consecutiveErrors >= maxConsecutiveErrors)
				{
					Print("Too many consecutive errors (" + consecutiveErrors + "). Stopping trading for safety.");
					return;
				}
				
				// Check if 10 minutes have passed since last trade
				bool canTrade = lastTradeTime == DateTime.MinValue || (Time[0] - lastTradeTime).TotalMinutes >= 10;
				
				// Condition 1: Buy at LevelB after dropping below LevelC within 5 minutes
				if (canTrade && canBuyAtLevelBFromC && 
					Close[0] >= LevelBValue && Low[0] <= LevelBValue)
				{
					try
					{
						_lastBar = CurrentBar;
						SetProfitTarget(CalculationMode.Ticks, TakeProfit);
						SetStopLoss(CalculationMode.Ticks, stopLossTicks);
						EnterLong(1, "BuyLevelB_FromC");
						canBuyAtLevelBFromC = false; // Reset condition after trade
						lastTradeTime = Time[0]; // Set last trade time
						Print("Market Buy executed at LevelB (" + LevelBValue + ") at " + Time[0].ToString("HH:mm:ss") + " after LevelC drop condition met");
						return;
					}
					catch (Exception ex)
					{
						Print("Error entering long at LevelB: " + ex.Message);
						HandleOrderError();
						return;
					}
				}
				
				// Condition 2: Sell at LevelB after rising above LevelA within 5 minutes
				if (canTrade && canSellAtLevelBFromA && 
					Close[0] <= LevelBValue && High[0] >= LevelBValue)
				{
					try
					{
						_lastBar = CurrentBar;
						SetProfitTarget(CalculationMode.Ticks, TakeProfit);
						SetStopLoss(CalculationMode.Ticks, stopLossTicks);
						EnterShort(1, "SellLevelB_FromA");
						canSellAtLevelBFromA = false; // Reset condition after trade
						lastTradeTime = Time[0]; // Set last trade time
						Print("Market Sell executed at LevelB (" + LevelBValue + ") at " + Time[0].ToString("HH:mm:ss") + " after LevelA rise condition met");
						return;
					}
					catch (Exception ex)
					{
						Print("Error entering short at LevelB: " + ex.Message);
						HandleOrderError();
						return;
					}
				}
				
				// Condition 3: Buy at LevelD after dropping below LevelA within 5 minutes
				if (canTrade && canBuyAtLevelDFromA && 
					Close[0] >= LevelDValue && Low[0] <= LevelDValue)
				{
					try
					{
						_lastBar = CurrentBar;
						SetProfitTarget(CalculationMode.Ticks, TakeProfit);
						SetStopLoss(CalculationMode.Ticks, stopLossTicks);
						EnterLong(1, "BuyLevelD_FromA");
						canBuyAtLevelDFromA = false; // Reset condition after trade
						lastTradeTime = Time[0]; // Set last trade time
						Print("Market Buy executed at LevelD (" + LevelDValue + ") at " + Time[0].ToString("HH:mm:ss") + " after LevelA drop condition met");
						return;
					}
					catch (Exception ex)
					{
						Print("Error entering long at LevelD: " + ex.Message);
						HandleOrderError();
						return;
					}
				}
				
				// Condition 4: Sell at LevelD after rising above LevelC within 5 minutes
				if (canTrade && canSellAtLevelDFromC && 
					Close[0] <= LevelDValue && High[0] >= LevelDValue)
				{
					try
					{
						_lastBar = CurrentBar;
						SetProfitTarget(CalculationMode.Ticks, TakeProfit);
						SetStopLoss(CalculationMode.Ticks, stopLossTicks);
						EnterShort(1, "SellLevelD_FromC");
						canSellAtLevelDFromC = false; // Reset condition after trade
						lastTradeTime = Time[0]; // Set last trade time
						Print("Market Sell executed at LevelD (" + LevelDValue + ") at " + Time[0].ToString("HH:mm:ss") + " after LevelC rise condition met");
						return;
					}
					catch (Exception ex)
					{
						Print("Error entering short at LevelD: " + ex.Message);
						HandleOrderError();
						return;
					}
				}

				if (
					(CrossBelow(barLow,LevelAValue, 1))
					||
					(CrossBelow(barLow,LevelBValue, 1))
					||
					(CrossBelow(barLow,LevelCValue, 1))
					||
					(CrossBelow(barLow,LevelDValue, 1))
					)
             
				{
////							if (orderId.Length == 0 && atmStrategyId.Length == 0)
////						{
////							isAtmStrategyCreated = false;  // reset atm strategy created check to false
////							atmStrategyId = GetAtmStrategyUniqueId();
////							orderId = GetAtmStrategyUniqueId();
////							AtmStrategyCreate(OrderAction.Buy, OrderType.Market, Close[0], 0, TimeInForce.Day, orderId, "AtmStrategyTemplate", atmStrategyId, (atmCallbackErrorCode, atmCallBackId) => {
////							//check that the atm strategy create did not result in error, and that the requested atm strategy matches the id in callback
////							if (atmCallbackErrorCode == ErrorCode.NoError && atmCallBackId == atmStrategyId)
////							isAtmStrategyCreated = true;
////							});
////						}
//						return;
//						}
                        }
				if (
					(CrossAbove(barHigh, LevelAValue, 1))
					||
					(CrossAbove(barHigh, LevelBValue, 1))
					||
					(CrossAbove(barHigh, LevelCValue, 1))
					||
					(CrossAbove(barHigh, LevelDValue, 1))
					)
					{
                	}
            	}
			
//			// Check that atm strategy was created before checking other properties
//			if (!isAtmStrategyCreated)
//				return;

//			// Check for a pending entry order
//			if (orderId.Length > 0)
//			{
//				string[] status = GetAtmStrategyEntryOrderStatus(orderId);

//				// If the status call can't find the order specified, the return array length will be zero otherwise it will hold elements
//				if (status.GetLength(0) > 0)
//				{
//					// Print out some information about the order to the output window
//					Print("The entry order average fill price is: " + status[0]);
//					Print("The entry order filled amount is: " + status[1]);
//					Print("The entry order order state is: " + status[2]);

//					// If the order state is terminal, reset the order id value
//					if (status[2] == "Filled" || status[2] == "Cancelled" || status[2] == "Rejected")
//						orderId = string.Empty;
//				}
//			} // If the strategy has terminated reset the strategy id
//			else if (atmStrategyId.Length > 0 && GetAtmStrategyMarketPosition(atmStrategyId) == Cbi.MarketPosition.Flat)
//				atmStrategyId = string.Empty;

//			if (atmStrategyId.Length > 0)
//			{
//				// You can change the stop price
//				if (GetAtmStrategyMarketPosition(atmStrategyId) != MarketPosition.Flat)
//					AtmStrategyChangeStopTarget(0, Low[0] - 3 * TickSize, "STOP1", atmStrategyId);

////				 Print some information about the strategy to the output window, please note you access the ATM strategy specific position object here
////				 the ATM would run self contained and would not have an impact on your NinjaScript strategy position and PnL
//				Print("The current ATM Strategy market position is: " + GetAtmStrategyMarketPosition(atmStrategyId));
//				Print("The current ATM Strategy position quantity is: " + GetAtmStrategyPositionQuantity(atmStrategyId));
//				Print("The current ATM Strategy average price is: " + GetAtmStrategyPositionAveragePrice(atmStrategyId));
//				Print("The current ATM Strategy Unrealized PnL is: " + GetAtmStrategyUnrealizedProfitLoss(atmStrategyId));
//			}
			
        	}
		
		private void HandleOrderError()
		{
			orderErrorOccurred = true;
			lastErrorTime = Time[0];
			consecutiveErrors++;
			
			// Cancel any pending orders if there's an error
			if (Position.MarketPosition != MarketPosition.Flat)
			{
				try
				{
					ExitLong();
					ExitShort();
					Print("Emergency exit executed due to order error at " + Time[0].ToString("HH:mm:ss"));
				}
				catch (Exception ex)
				{
					Print("Error during emergency exit: " + ex.Message);
				}
			}
		}
		
		protected override void OnOrderUpdate(Order order, double limitPrice, double stopPrice, int quantity, int filled, double averageFillPrice, OrderState orderState, DateTime time, ErrorCode error)
		{
			// Handle order state changes
			if (orderState == OrderState.Filled)
			{
				consecutiveErrors = 0;
				orderErrorOccurred = false;
				Print("Order filled successfully: " + order.Name);
			}
			else if (orderState == OrderState.Rejected || orderState == OrderState.Cancelled)
			{
				Print("Order " + orderState.ToString() + ": " + order.Name);
				HandleOrderError();
			}
		}
		
		protected override void OnExecutionUpdate(Execution execution, string executionId, double price, int quantity, MarketPosition marketPosition, string orderId, DateTime time)
		{
			// Track wins and losses
			if (execution.Order != null && execution.Order.OrderAction == OrderAction.BuyToCover || execution.Order.OrderAction == OrderAction.Sell)
			{
				if (SystemPerformance.AllTrades.Count > 0)
				{
					Trade lastTrade = SystemPerformance.AllTrades[SystemPerformance.AllTrades.Count - 1];
					if (lastTrade.ProfitCurrency > 0)
					{
						dailyWins++;
						Print("Trade WIN #" + dailyWins + " - Profit: $" + lastTrade.ProfitCurrency.ToString("F2"));
					}
					else if (lastTrade.ProfitCurrency < 0)
					{
						dailyLosses++;
						Print("Trade LOSS #" + dailyLosses + " - Loss: $" + lastTrade.ProfitCurrency.ToString("F2"));
					}
				}
			}
		}

        #region Properties
		
		[Browsable(false)]
		[XmlIgnore]		
        public Series<double>  BarHigh
        {
            get { return barHigh; }	// Allows our public BullIndication Series<bool> to access and expose our interal bullIndication Series<bool>
        }
		[Browsable(false)]
		[XmlIgnore]		
        public Series<double>  BarLow
        {
            get { return barLow; }	// Allows our public BullIndication Series<bool> to access and expose our interal bullIndication Series<bool>
        }
		[Browsable(false)]
		[XmlIgnore]		
        public Series<double>  BarClose
        {
            get { return barClose; }	// Allows our public BullIndication Series<bool> to access and expose our interal bullIndication Series<bool>
        }
		
        [Range(0, int.MaxValue), NinjaScriptProperty]
        [Display(ResourceType = typeof(Custom.Resource), Name = "Take Profit (ticks)", GroupName = "01. Parameters", Order = 0)]
        public int TakeProfit { get; set; }

        [Range(0, int.MaxValue), NinjaScriptProperty]
        [Display(ResourceType = typeof(Custom.Resource), Name = "Extra SL (ticks)", GroupName = "01. Parameters", Order = 1)]
        public int ExtraSLTicks { get; set; }
		
        [Range(0, int.MaxValue), NinjaScriptProperty]
        [Display(ResourceType = typeof(Custom.Resource), Name = "Extra Retracement (ticks)", GroupName = "01. Parameters", Order = 2)]
        public int ExtraRetracementTicks { get; set; }

//        [Range(0, int.MaxValue), NinjaScriptProperty]
//        [Display(ResourceType = typeof(Custom.Resource), Name = "Min. Touches", GroupName = "01. Parameters", Order = 3)]
//        public int MinTouches { get; set; }

		
 		[Range(0, int.MaxValue)]
		[NinjaScriptProperty]
		[Display(Name="Profit Target Ticks", Description="Number of ticks away from entry price for the Profit Target order", Order=1, GroupName="Parameters")]
		public int ProfitTargetTicks
		{
			get { return profitTargetTicks; }
			set { profitTargetTicks = value; }
		}

		[Range(0, int.MaxValue)]
		[NinjaScriptProperty]
		[Display(Name="Stop Loss Ticks", Description="Numbers of ticks away from entry price for the Stop Loss order", Order=2, GroupName="Parameters")]
		public int StopLossTicks
		{
			get { return stopLossTicks; }
			set { stopLossTicks = value; }
		}

		[Range(0, int.MaxValue)]
		[NinjaScriptProperty]
		[Display(Name="BreakEven Ticks Trigger", Description="Number of ticks in Profit to trigger stop to move to Plus Breakeven ticks level", Order=3, GroupName="Parameters")]
		public int BreakEvenTicks
		{
			get {return breakEvenTicks;}
			set {breakEvenTicks = value;}
		}

		[Range(0, int.MaxValue)]
		[NinjaScriptProperty]
		[Display(Name="BreakEven Ticks level", Description="Number of ticks past breakeven for breakeven stop (can be zero)", Order=4, GroupName="Parameters")]
		public int PlusBreakEven
		{
			get { return plusBreakEven; }
			set { plusBreakEven = value; }
		}

		[Range(0, int.MaxValue)]
		[NinjaScriptProperty]
		[Display(Name="Trail Profit Trigger", Description="Number of ticks in profit to trigger trail stop action", Order=5, GroupName="Parameters")]
		public int TrailProfitTrigger
		{
			get {return trailProfitTrigger;}
			set {trailProfitTrigger = value;}
		}
		
		[Range(0, int.MaxValue)]
		[NinjaScriptProperty]
		[Display(Name="Trail Step Ticks", Description="Number of ticks to step for each adjustment of trail stop", Order=6, GroupName="Parameters")]
		public int TrailStepTicks
		{
			get {return trailStepTicks;}
			set {trailStepTicks = value;}
		}
		
		[Range(1, int.MaxValue)]
		[NinjaScriptProperty]
		[Display(Name="Trailing Stop Ticks", Description="Number of ticks for trailing stop distance", Order=7, GroupName="Parameters")]
		public int TrailingStopTicks
		{
			get {return trailingStopTicks;}
			set {trailingStopTicks = value;}
		}
		
		[NinjaScriptProperty]
		[Display(Name = "Show Lines", Description="Plot profit and stop lines on chart", Order = 8, GroupName = "Parameters")]
		public bool ShowLines
		{
			get { return showLines; } 
			set { showLines = value; }
		}		

		[Browsable(false)]
		[XmlIgnore]
		public Series<double> ProfitTarget
		{
			get { return Values[0]; }
		}

		[Browsable(false)]
		[XmlIgnore]
		public Series<double> StopLoss
		{
			get { return Values[1]; }
		}
		
		[Range(0, int.MaxValue), NinjaScriptProperty]
        [Display(Name = "Level A", Order = 9, GroupName = "Parameters")]
        public int LevelA { get; set; }

        [Range(0, int.MaxValue), NinjaScriptProperty]
        [Display(Name = "Level B", Order = 10, GroupName = "Parameters")]
        public int LevelB { get; set; }

        [Range(0, int.MaxValue), NinjaScriptProperty]
        [Display(Name = "Level C", Order = 11, GroupName = "Parameters")]
        public int LevelC { get; set; }

        [Range(0, int.MaxValue), NinjaScriptProperty]
        [Display(Name = "Level D", Order = 12, GroupName = "Parameters")]
        public int LevelD { get; set; }

		[NinjaScriptProperty]
		[Display(Name = "Level A Line", Order = 13, GroupName = "Parameters")]
		public Stroke LevelALine { get; set; }		

		[NinjaScriptProperty]
		[Display(Name = "Level B Line", Order = 14, GroupName = "Parameters")]
		public Stroke LevelBLine { get; set; }		

		[NinjaScriptProperty]
		[Display(Name = "Level C Line", Order = 15, GroupName = "Parameters")]
		public Stroke LevelCLine { get; set; }		

		[NinjaScriptProperty]
		[Display(Name = "Level D Line", Order = 16, GroupName = "Parameters")]
		public Stroke LevelDLine { get; set; }
		
		[Range(1, int.MaxValue)]
		[NinjaScriptProperty]
		[Display(Name="Max Wins Per Day", Description="Maximum number of winning trades allowed per day", Order=17, GroupName="Parameters")]
		public int MaxWinsPerDay
		{
			get { return maxWinsPerDay; }
			set { maxWinsPerDay = value; }
		}
		
		[Range(1, int.MaxValue)]
		[NinjaScriptProperty]
		[Display(Name="Max Losses Per Day", Description="Maximum number of losing trades allowed per day", Order=18, GroupName="Parameters")]
		public int MaxLossesPerDay
		{
			get { return maxLossesPerDay; }
			set { maxLossesPerDay = value; }
		}
        #endregion
    }
}


